split_file	scripts\benchmark.sh	/^split_file(){$/;"	f
split_file	scripts\cache.sh	/^split_file(){$/;"	f
split_file	scripts\caf.sh	/^split_file(){$/;"	f
split_file	scripts\hybrid.sh	/^split_file(){$/;"	f
split_file	scripts\rewrite.sh	/^split_file(){$/;"	f
ae_chunk_data	src\ae_chunking.cpp	/^int ae_chunk_data(unsigned char *p, int n) {$/;"	f
ae_init	src\ae_chunking.cpp	/^void ae_init(){$/;"	f
my_memcmp	src\ae_chunking.cpp	8;"	d	file:
window_size	src\ae_chunking.cpp	/^static int window_size = 0;$/;"	v	file:
area	src\assembly_restore.cpp	/^	GSequence *area;$/;"	m	struct:__anon1	file:
area_size	src\assembly_restore.cpp	/^	int64_t area_size;$/;"	m	struct:__anon1	file:
assemble_area	src\assembly_restore.cpp	/^static GQueue* assemble_area() {$/;"	f	file:
assembly_area	src\assembly_restore.cpp	/^} assembly_area;$/;"	v	typeref:struct:__anon1
assembly_area_push	src\assembly_restore.cpp	/^static int assembly_area_push(struct chunk* c) {$/;"	f	file:
assembly_restore_thread	src\assembly_restore.cpp	/^void* assembly_restore_thread(void *arg) {$/;"	f
init_assembly_area	src\assembly_restore.cpp	/^static void init_assembly_area() {$/;"	f	file:
size	src\assembly_restore.cpp	/^	int64_t size;$/;"	m	struct:__anon1	file:
BACKUP_H_	src\backup.h	9;"	d
DEKHash	src\bloom_filter.cpp	/^unsigned int DEKHash(unsigned char *str, unsigned int len)$/;"	f
DJBHash	src\bloom_filter.cpp	/^unsigned int DJBHash(unsigned char *str, unsigned int len)$/;"	f
FNVHash	src\bloom_filter.cpp	/^unsigned int FNVHash(unsigned char *str, unsigned int len)$/;"	f
JSHash	src\bloom_filter.cpp	/^unsigned int JSHash(unsigned char *str, unsigned int len)$/;"	f
PJWHash	src\bloom_filter.cpp	/^unsigned int PJWHash(unsigned char *str, unsigned int len)$/;"	f
RSHash	src\bloom_filter.cpp	/^unsigned int RSHash(unsigned char *str, unsigned int len)$/;"	f
SDBMHash	src\bloom_filter.cpp	/^unsigned int SDBMHash(unsigned char *str, unsigned int len)$/;"	f
hash_func	src\bloom_filter.cpp	/^unsigned int (*hash_func[])(unsigned char *, unsigned int) = { $/;"	v
in_dict	src\bloom_filter.cpp	/^int in_dict(unsigned char filter[], char *str, int len)$/;"	f
insert_word	src\bloom_filter.cpp	/^void insert_word(unsigned char filter[], char *str, int len)$/;"	f
BF_H_	src\bloom_filter.h	2;"	d
FILTER_BITMASK	src\bloom_filter.h	10;"	d
FILTER_SIZE	src\bloom_filter.h	7;"	d
FILTER_SIZE_BYTES	src\bloom_filter.h	9;"	d
NUM_HASHES	src\bloom_filter.h	8;"	d
Node	src\cap_rewrite.cpp	/^}Node[MAX_CONTAINER_COUNT];$/;"	v	typeref:struct:containerchunkcount
all_fp	src\cap_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
cap_rewrite	src\cap_rewrite.cpp	/^void *cap_rewrite(void* arg) {$/;"	f
chunk_num	src\cap_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunkcount	src\cap_rewrite.cpp	/^	int64_t chunkcount;$/;"	m	struct:containerchunkcount	file:
cond	src\cap_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
containerchunkcount	src\cap_rewrite.cpp	/^	containerchunkcount() {$/;"	f	struct:containerchunkcount
containerchunkcount	src\cap_rewrite.cpp	/^struct containerchunkcount{$/;"	s	file:
id	src\cap_rewrite.cpp	/^	int64_t id;$/;"	m	struct:containerchunkcount	file:
mutex	src\cap_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
operator <	src\cap_rewrite.cpp	/^	bool operator < (const containerchunkcount &a) const {$/;"	f	struct:containerchunkcount
real_containerid_to_tmp	src\cap_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
rewrite_buffer_chunk_pt	src\cap_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
structindexlock	src\cap_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
tmp_to_real_containerid	src\cap_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
top	src\cap_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
wait_threshold	src\cap_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
buckets	src\cbr_rewrite.cpp	/^	int32_t buckets[10000];$/;"	m	struct:__anon2	file:
cbr_rewrite	src\cbr_rewrite.cpp	/^void *cbr_rewrite(void* arg) {$/;"	f
chunk_num	src\cbr_rewrite.cpp	/^	int32_t chunk_num;$/;"	m	struct:__anon2	file:
chunk_num	src\cbr_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
current_utility_threshold	src\cbr_rewrite.cpp	/^	double current_utility_threshold;$/;"	m	struct:__anon2	file:
get_rewrite_utility	src\cbr_rewrite.cpp	/^static double get_rewrite_utility(struct chunk *c) {$/;"	f	file:
init_utility_buckets	src\cbr_rewrite.cpp	/^void init_utility_buckets() {$/;"	f
min_index	src\cbr_rewrite.cpp	/^	int min_index;$/;"	m	struct:__anon2	file:
utility_buckets	src\cbr_rewrite.cpp	/^} utility_buckets;$/;"	v	typeref:struct:__anon2
utility_buckets_update	src\cbr_rewrite.cpp	/^static void utility_buckets_update(double rewrite_utility) {$/;"	f	file:
cfl_rewrite	src\cfl_rewrite.cpp	/^void *cfl_rewrite(void* arg) {$/;"	f
chunk_num	src\cfl_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	src\chunk_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_queue	src\chunk_phase.cpp	/^SyncQueue* chunk_queue;$/;"	v
chunk_t	src\chunk_phase.cpp	/^static pthread_t chunk_t;$/;"	v	file:
chunk_thread	src\chunk_phase.cpp	/^static void* chunk_thread(void *arg) {$/;"	f	file:
chunking	src\chunk_phase.cpp	/^static int (*chunking)(unsigned char* buf, int size);$/;"	v	file:
fixed_chunk_data	src\chunk_phase.cpp	/^static inline int fixed_chunk_data(unsigned char* buf, int size){$/;"	f	file:
start_chunk_phase	src\chunk_phase.cpp	/^void start_chunk_phase() {$/;"	f
stop_chunk_phase	src\chunk_phase.cpp	/^void stop_chunk_phase() {$/;"	f
CHUNK_H_	src\chunking.h	6;"	d
id	src\cma.cpp	/^    containerid id;$/;"	m	struct:record	file:
record	src\cma.cpp	/^struct record{$/;"	s	file:
time	src\cma.cpp	/^    int time;$/;"	m	struct:record	file:
trunc_manifest	src\cma.cpp	/^GHashTable* trunc_manifest(int jobid){$/;"	f
update_manifest	src\cma.cpp	/^void update_manifest(GHashTable *monitor){$/;"	f
CMA_H_	src\cma.h	2;"	d
load_config	src\config.cpp	/^void load_config() {$/;"	f
load_config_from_string	src\config.cpp	/^void load_config_from_string(sds config) {$/;"	f
yesnotoi	src\config.cpp	/^int yesnotoi(char *s) {$/;"	f
add_chunk_to_container	src\containerstore.cpp	/^int add_chunk_to_container(struct container* c, struct chunk* ck) {$/;"	f
append_t	src\containerstore.cpp	/^static pthread_t append_t;$/;"	v	file:
append_thread	src\containerstore.cpp	/^static void* append_thread(void *arg) {$/;"	f	file:
close_container_store	src\containerstore.cpp	/^void close_container_store() {$/;"	f
container_buffer	src\containerstore.cpp	/^static SyncQueue* container_buffer;$/;"	v	file:
container_check_id	src\containerstore.cpp	/^int container_check_id(void *c1, void *id1) {$/;"	f
container_count	src\containerstore.cpp	/^static int64_t container_count = 0;$/;"	v	file:
container_empty	src\containerstore.cpp	/^int container_empty(struct container* c) {$/;"	f
container_meta_check_id	src\containerstore.cpp	/^int container_meta_check_id(void *cm1, void *id1) {$/;"	f
container_meta_duplicate	src\containerstore.cpp	/^static void * container_meta_duplicate(void *c1) {$/;"	f	file:
container_meta_foreach	src\containerstore.cpp	/^void container_meta_foreach(struct containerMeta* cm, void (*func)(fingerprint*, void*), void* data){$/;"	f
container_overflow	src\containerstore.cpp	/^int container_overflow(struct container* c, int32_t size) {$/;"	f
create_container	src\containerstore.cpp	/^struct container* create_container() {$/;"	f
fp	src\containerstore.cpp	/^	fingerprint fp;$/;"	m	struct:metaEntry	file:
fp	src\containerstore.cpp	/^static FILE* fp;$/;"	v	file:
free_container	src\containerstore.cpp	/^void free_container(void * c1) {$/;"	f
free_container_meta	src\containerstore.cpp	/^void free_container_meta(void * cm1){$/;"	f
g_container_cmp_desc	src\containerstore.cpp	/^gint g_container_cmp_desc(struct container* c1, struct container* c2,$/;"	f
g_container_meta_cmp_desc	src\containerstore.cpp	/^gint g_container_meta_cmp_desc(struct containerMeta* cm1,$/;"	f
get_chunk_in_container	src\containerstore.cpp	/^struct chunk* get_chunk_in_container(struct container* c, fingerprint *fp) {$/;"	f
get_container_id	src\containerstore.cpp	/^containerid get_container_id(struct container* c) {$/;"	f
get_metaentry_in_container_meta	src\containerstore.cpp	/^static struct metaEntry* get_metaentry_in_container_meta($/;"	f	file:
init_container_meta	src\containerstore.cpp	/^static void init_container_meta(struct containerMeta *meta) {$/;"	f	file:
init_container_store	src\containerstore.cpp	/^void init_container_store() {$/;"	f
len	src\containerstore.cpp	/^	int32_t len;$/;"	m	struct:metaEntry	file:
lookup_fingerprint_in_container	src\containerstore.cpp	/^int lookup_fingerprint_in_container(void *c1, void *fp1) {$/;"	f
lookup_fingerprint_in_container_meta	src\containerstore.cpp	/^int lookup_fingerprint_in_container_meta(void *cm1, void *fp1) {$/;"	f
metaEntry	src\containerstore.cpp	/^struct metaEntry {$/;"	s	file:
mutex	src\containerstore.cpp	/^static pthread_mutex_t mutex;$/;"	v	file:
off	src\containerstore.cpp	/^	int32_t off;$/;"	m	struct:metaEntry	file:
retrieve_container_by_id	src\containerstore.cpp	/^struct container* retrieve_container_by_id(containerid id) {$/;"	f
retrieve_container_meta_by_id	src\containerstore.cpp	/^struct containerMeta* retrieve_container_meta_by_id(containerid id) {$/;"	f
write_container	src\containerstore.cpp	/^void write_container(struct container* c) {$/;"	f
write_container_async	src\containerstore.cpp	/^void write_container_async(struct container* c) {$/;"	f
CONTAINERSTORE_H_	src\containerstore.h	9;"	d
CONTAINER_HEAD	src\containerstore.h	15;"	d
CONTAINER_META_ENTRY	src\containerstore.h	16;"	d
CONTAINER_META_SIZE	src\containerstore.h	14;"	d
CONTAINER_SIZE	src\containerstore.h	13;"	d
chunk_num	src\containerstore.h	/^	int32_t chunk_num;$/;"	m	struct:containerMeta
container	src\containerstore.h	/^struct container {$/;"	s
containerMeta	src\containerstore.h	/^struct containerMeta {$/;"	s
data	src\containerstore.h	/^	unsigned char *data;$/;"	m	struct:container
data_size	src\containerstore.h	/^	int32_t data_size;$/;"	m	struct:containerMeta
id	src\containerstore.h	/^	containerid id;$/;"	m	struct:containerMeta
map	src\containerstore.h	/^	GHashTable *map;$/;"	m	struct:containerMeta
meta	src\containerstore.h	/^	struct containerMeta meta;$/;"	m	struct:container	typeref:struct:container::containerMeta
chunk_num	src\dedup_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
cond	src\dedup_phase.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
dedup_queue	src\dedup_phase.cpp	/^SyncQueue* dedup_queue;$/;"	v
dedup_t	src\dedup_phase.cpp	/^static pthread_t dedup_t;$/;"	v	file:
dedup_thread	src\dedup_phase.cpp	/^void *dedup_thread(void *arg) {$/;"	f
index_lock	src\dedup_phase.cpp	/^struct structindexlock index_lock;$/;"	v	typeref:struct:structindexlock
mutex	src\dedup_phase.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
segment_num	src\dedup_phase.cpp	/^static int64_t segment_num;$/;"	v	file:
send_segment	src\dedup_phase.cpp	/^void send_segment(struct segment* s) {$/;"	f
start_dedup_phase	src\dedup_phase.cpp	/^void start_dedup_phase() {$/;"	f
stop_dedup_phase	src\dedup_phase.cpp	/^void stop_dedup_phase() {$/;"	f
structindexlock	src\dedup_phase.cpp	/^struct structindexlock{$/;"	s	file:
wait_threshold	src\dedup_phase.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
check_simulation_level	src\destor.cpp	/^void check_simulation_level(int last_level, int current_level) {$/;"	f
code2hash	src\destor.cpp	/^void code2hash(unsigned char code[40], unsigned char hash[20]) {$/;"	f
destor	src\destor.cpp	/^struct structdestor destor;$/;"	v	typeref:struct:structdestor
destor_log	src\destor.cpp	/^void destor_log(int level, const char *fmt, ...) {$/;"	f
destor_shutdown	src\destor.cpp	/^void destor_shutdown() {$/;"	f
destor_start	src\destor.cpp	/^void destor_start() {$/;"	f
destor_stat	src\destor.cpp	/^void destor_stat() {$/;"	f
free_chunk	src\destor.cpp	/^void free_chunk(struct chunk* ck) {$/;"	f
free_segment	src\destor.cpp	/^void free_segment(struct segment* s) {$/;"	f
g_chunk_cmp	src\destor.cpp	/^gint g_chunk_cmp(struct chunk* a, struct chunk* b, gpointer user_data){$/;"	f
g_fingerprint_cmp	src\destor.cpp	/^gint g_fingerprint_cmp(fingerprint* fp1, fingerprint* fp2, gpointer user_data) {$/;"	f
g_fingerprint_equal	src\destor.cpp	/^gboolean g_fingerprint_equal(fingerprint* fp1, fingerprint* fp2) {$/;"	f
hash2code	src\destor.cpp	/^void hash2code(unsigned char hash[20], char code[40]) {$/;"	f
long_options	src\destor.cpp	/^struct option long_options[] = {$/;"	v	typeref:struct:option
main	src\destor.cpp	/^int main(int argc, char **argv) {$/;"	f
new_chunk	src\destor.cpp	/^struct chunk* new_chunk(int32_t size) {$/;"	f
new_segment	src\destor.cpp	/^struct segment* new_segment() {$/;"	f
new_segment_full	src\destor.cpp	/^struct segment* new_segment_full(){$/;"	f
short_options	src\destor.cpp	/^const char * const short_options = "sr::t::p::h";$/;"	v
usage	src\destor.cpp	/^void usage() {$/;"	f
CHECK_CHUNK	src\destor.h	194;"	d
CHUNK_AE	src\destor.h	70;"	d
CHUNK_DUPLICATE	src\destor.h	174;"	d
CHUNK_FILE	src\destor.h	69;"	d
CHUNK_FILE_END	src\destor.h	184;"	d
CHUNK_FILE_START	src\destor.h	183;"	d
CHUNK_FIXED	src\destor.h	66;"	d
CHUNK_IN_CACHE	src\destor.h	178;"	d
CHUNK_NORMALIZED_RABIN	src\destor.h	68;"	d
CHUNK_OUT_OF_ORDER	src\destor.h	176;"	d
CHUNK_RABIN	src\destor.h	67;"	d
CHUNK_READY	src\destor.h	190;"	d
CHUNK_REWRITE_DENIED	src\destor.h	180;"	d
CHUNK_SEGMENT_END	src\destor.h	186;"	d
CHUNK_SEGMENT_START	src\destor.h	185;"	d
CHUNK_SPARSE	src\destor.h	175;"	d
CHUNK_TTTD	src\destor.h	71;"	d
CHUNK_UNIQUE	src\destor.h	173;"	d
CHUNK_WAIT	src\destor.h	189;"	d
DEBUG	src\destor.h	324;"	d
DEFAULT_BLOCK_SIZE	src\destor.h	170;"	d
DESTOR_BACKUP	src\destor.h	43;"	d
DESTOR_CONFIGLINE_MAX	src\destor.h	41;"	d
DESTOR_DEBUG	src\destor.h	49;"	d
DESTOR_DEFAULT_VERBOSITY	src\destor.h	53;"	d
DESTOR_DELETE	src\destor.h	46;"	d
DESTOR_H_	src\destor.h	9;"	d
DESTOR_MAKE_TRACE	src\destor.h	45;"	d
DESTOR_MAX_LOGMSG_LEN	src\destor.h	54;"	d
DESTOR_NOTICE	src\destor.h	51;"	d
DESTOR_RESTORE	src\destor.h	44;"	d
DESTOR_VERBOSE	src\destor.h	50;"	d
DESTOR_WARNING	src\destor.h	52;"	d
INDEX_CATEGORY_EXACT	src\destor.h	80;"	d
INDEX_CATEGORY_LOGICAL	src\destor.h	95;"	d
INDEX_CATEGORY_LOGICAL_LOCALITY	src\destor.h	102;"	d
INDEX_CATEGORY_NEAR_EXACT	src\destor.h	87;"	d
INDEX_CATEGORY_PHYSICAL_LOCALITY	src\destor.h	94;"	d
INDEX_CATEGORY_SIMILARITY	src\destor.h	103;"	d
INDEX_KEY_VALUE_HTABLE	src\destor.h	109;"	d
INDEX_KEY_VALUE_MYSQL	src\destor.h	110;"	d
INDEX_SAMPLING_MIN	src\destor.h	122;"	d
INDEX_SAMPLING_OPTIMIZED_MIN	src\destor.h	124;"	d
INDEX_SAMPLING_RANDOM	src\destor.h	121;"	d
INDEX_SAMPLING_UNIFORM	src\destor.h	123;"	d
INDEX_SEGMENT_CONTENT_DEFINED	src\destor.h	132;"	d
INDEX_SEGMENT_FILE_DEFINED	src\destor.h	133;"	d
INDEX_SEGMENT_FIXED	src\destor.h	131;"	d
INDEX_SEGMENT_SELECT_BASE	src\destor.h	140;"	d
INDEX_SEGMENT_SELECT_MIX	src\destor.h	142;"	d
INDEX_SEGMENT_SELECT_TOP	src\destor.h	141;"	d
INDEX_SPECIFIC_BLOCK_LOCALITY_CACHING	src\destor.h	154;"	d
INDEX_SPECIFIC_DDFS	src\destor.h	149;"	d
INDEX_SPECIFIC_EXTREME_BINNING	src\destor.h	150;"	d
INDEX_SPECIFIC_NO	src\destor.h	148;"	d
INDEX_SPECIFIC_SAMPLED	src\destor.h	153;"	d
INDEX_SPECIFIC_SILO	src\destor.h	151;"	d
INDEX_SPECIFIC_SPARSE	src\destor.h	152;"	d
NOTICE	src\destor.h	326;"	d
RESTORE_CACHE_ASM	src\destor.h	158;"	d
RESTORE_CACHE_LRU	src\destor.h	156;"	d
RESTORE_CACHE_OPT	src\destor.h	157;"	d
REWRITE_CAPPING	src\destor.h	163;"	d
REWRITE_CFL_SELECTIVE_DEDUPLICATION	src\destor.h	161;"	d
REWRITE_CONTEXT_BASED	src\destor.h	162;"	d
REWRITE_NED	src\destor.h	165;"	d
REWRITE_NO	src\destor.h	160;"	d
REWRITE_SMR	src\destor.h	164;"	d
SET_CHUNK	src\destor.h	192;"	d
SIMULATION_ALL	src\destor.h	60;"	d
SIMULATION_APPEND	src\destor.h	59;"	d
SIMULATION_NO	src\destor.h	57;"	d
SIMULATION_RESTORE	src\destor.h	58;"	d
TEMPORARY_ID	src\destor.h	167;"	d
TIMER_BEGIN	src\destor.h	37;"	d
TIMER_DECLARE	src\destor.h	36;"	d
TIMER_END	src\destor.h	38;"	d
TRACE_DESTOR	src\destor.h	63;"	d
TRACE_FSL	src\destor.h	64;"	d
UNSET_CHUNK	src\destor.h	193;"	d
VERBOSE	src\destor.h	325;"	d
WARNING	src\destor.h	327;"	d
backup_retention_time	src\destor.h	/^	int backup_retention_time;$/;"	m	struct:structdestor
chunk	src\destor.h	/^struct chunk {$/;"	s
chunk_algorithm	src\destor.h	/^	int chunk_algorithm;$/;"	m	struct:structdestor
chunk_avg_size	src\destor.h	/^	int chunk_avg_size;$/;"	m	struct:structdestor
chunk_max_size	src\destor.h	/^	int chunk_max_size;$/;"	m	struct:structdestor
chunk_min_size	src\destor.h	/^	int chunk_min_size;$/;"	m	struct:structdestor
chunk_num	src\destor.h	/^	int32_t chunk_num;$/;"	m	struct:segment
chunk_num	src\destor.h	/^	int64_t chunk_num;$/;"	m	struct:structdestor
chunks	src\destor.h	/^	GSequence *chunks;$/;"	m	struct:segment
containerid	src\destor.h	/^typedef int64_t containerid; \/\/container id$/;"	t
data	src\destor.h	/^	unsigned char *data;$/;"	m	struct:chunk
data_size	src\destor.h	/^	int64_t data_size;$/;"	m	struct:structdestor
features	src\destor.h	/^	GHashTable* features;$/;"	m	struct:segment
fingerprint	src\destor.h	/^typedef unsigned char fingerprint[20];$/;"	t
flag	src\destor.h	/^	int flag;$/;"	m	struct:chunk
fp	src\destor.h	/^	fingerprint fp;$/;"	m	struct:chunk
id	src\destor.h	/^	containerid id;$/;"	m	struct:chunk
id	src\destor.h	/^	segmentid id;$/;"	m	struct:segment
index_bloom_filter_size	src\destor.h	/^	int index_bloom_filter_size;$/;"	m	struct:structdestor
index_cache_size	src\destor.h	/^	int index_cache_size;$/;"	m	struct:structdestor
index_category	src\destor.h	/^	int index_category[2];$/;"	m	struct:structdestor
index_key_size	src\destor.h	/^	int index_key_size;$/;"	m	struct:structdestor
index_key_value_store	src\destor.h	/^	int index_key_value_store;$/;"	m	struct:structdestor
index_memory_footprint	src\destor.h	/^	int32_t index_memory_footprint;$/;"	m	struct:structdestor
index_sampling_method	src\destor.h	/^	int index_sampling_method[2];$/;"	m	struct:structdestor
index_segment_algorithm	src\destor.h	/^	int index_segment_algorithm[2];$/;"	m	struct:structdestor
index_segment_max	src\destor.h	/^	int index_segment_max;$/;"	m	struct:structdestor
index_segment_min	src\destor.h	/^	int index_segment_min;$/;"	m	struct:structdestor
index_segment_prefech	src\destor.h	/^	int index_segment_prefech;$/;"	m	struct:structdestor
index_segment_selection_method	src\destor.h	/^	int index_segment_selection_method[2];$/;"	m	struct:structdestor
index_specific	src\destor.h	/^	int index_specific;$/;"	m	struct:structdestor
index_value_length	src\destor.h	/^	int index_value_length;$/;"	m	struct:structdestor
live_container_num	src\destor.h	/^	int32_t live_container_num;$/;"	m	struct:structdestor
restore_cache	src\destor.h	/^	int restore_cache[2];$/;"	m	struct:structdestor
restore_opt_window_size	src\destor.h	/^	int restore_opt_window_size;$/;"	m	struct:structdestor
rewrite_algorithm	src\destor.h	/^	int rewrite_algorithm[2];$/;"	m	struct:structdestor
rewrite_capping_level	src\destor.h	/^	int rewrite_capping_level;$/;"	m	struct:structdestor
rewrite_cbr_limit	src\destor.h	/^	double rewrite_cbr_limit;$/;"	m	struct:structdestor
rewrite_cbr_minimal_utility	src\destor.h	/^	double rewrite_cbr_minimal_utility;$/;"	m	struct:structdestor
rewrite_cfl_require	src\destor.h	/^	double rewrite_cfl_require;$/;"	m	struct:structdestor
rewrite_cfl_usage_threshold	src\destor.h	/^	double rewrite_cfl_usage_threshold;$/;"	m	struct:structdestor
rewrite_enable_cache_aware	src\destor.h	/^	int rewrite_enable_cache_aware;$/;"	m	struct:structdestor
rewrite_enable_cfl_switch	src\destor.h	/^	int rewrite_enable_cfl_switch;$/;"	m	struct:structdestor
rewrite_enable_har	src\destor.h	/^	int rewrite_enable_har;$/;"	m	struct:structdestor
rewrite_har_rewrite_limit	src\destor.h	/^	double rewrite_har_rewrite_limit;$/;"	m	struct:structdestor
rewrite_har_utilization_threshold	src\destor.h	/^	double rewrite_har_utilization_threshold;$/;"	m	struct:structdestor
rewrite_ned_level	src\destor.h	/^	int rewrite_ned_level;$/;"	m	struct:structdestor
rewrite_smr_level	src\destor.h	/^	int rewrite_smr_level;$/;"	m	struct:structdestor
rewritten_chunk_num	src\destor.h	/^	int64_t rewritten_chunk_num;$/;"	m	struct:structdestor
rewritten_chunk_size	src\destor.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:structdestor
segment	src\destor.h	/^struct segment {$/;"	s
segmentid	src\destor.h	/^typedef int64_t segmentid;$/;"	t
simulation_level	src\destor.h	/^	int simulation_level;$/;"	m	struct:structdestor
size	src\destor.h	/^	int32_t size;$/;"	m	struct:chunk
stored_chunk_num	src\destor.h	/^	int64_t stored_chunk_num;$/;"	m	struct:structdestor
stored_data_size	src\destor.h	/^	int64_t stored_data_size;$/;"	m	struct:structdestor
structdestor	src\destor.h	/^struct structdestor {$/;"	s
trace_format	src\destor.h	/^    int trace_format;$/;"	m	struct:structdestor
verbosity	src\destor.h	/^	int verbosity;$/;"	m	struct:structdestor
working_directory	src\destor.h	/^	sds working_directory;$/;"	m	struct:structdestor
zero_chunk_num	src\destor.h	/^	int64_t zero_chunk_num;$/;"	m	struct:structdestor
zero_chunk_size	src\destor.h	/^	int64_t zero_chunk_size;$/;"	m	struct:structdestor
do_backup	src\do_backup.cpp	/^void do_backup(char *path) {$/;"	f
lookup_requests	src\do_backup.cpp	/^	int lookup_requests;$/;"	m	struct:__anon3	file:
lookup_requests_for_unique	src\do_backup.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon3	file:
read_prefetching_units	src\do_backup.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon3	file:
update_requests	src\do_backup.cpp	/^	int update_requests;$/;"	m	struct:__anon3	file:
delete_an_entry	src\do_delete.cpp	/^static inline void delete_an_entry(fingerprint *fp, void *id1){$/;"	f	file:
do_delete	src\do_delete.cpp	/^void do_delete(int jobid) {$/;"	f
do_restore	src\do_restore.cpp	/^void do_restore(int revision, char *path) {$/;"	f
lru_restore_thread	src\do_restore.cpp	/^static void* lru_restore_thread(void *arg) {$/;"	f	file:
read_recipe_thread	src\do_restore.cpp	/^static void* read_recipe_thread(void *arg) {$/;"	f	file:
restore_chunk_queue	src\do_restore.cpp	/^SyncQueue *restore_chunk_queue;$/;"	v
restore_recipe_queue	src\do_restore.cpp	/^SyncQueue *restore_recipe_queue;$/;"	v
write_restore_data	src\do_restore.cpp	/^void* write_restore_data(void* arg) {$/;"	f
chunk_num	src\filter_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunks	src\filter_phase.cpp	/^	GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
cond	src\filter_phase.cpp	/^    pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
container_buffer	src\filter_phase.cpp	/^	struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
filter_t	src\filter_phase.cpp	/^static pthread_t filter_t;$/;"	v	file:
filter_thread	src\filter_phase.cpp	/^static void* filter_thread(void *arg) {$/;"	f	file:
mutex	src\filter_phase.cpp	/^    pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
start_filter_phase	src\filter_phase.cpp	/^void start_filter_phase() {$/;"	f
stop_filter_phase	src\filter_phase.cpp	/^void stop_filter_phase() {$/;"	f
storage_buffer	src\filter_phase.cpp	/^struct structstoragebuffer storage_buffer;$/;"	v	typeref:struct:structstoragebuffer
structindexlock	src\filter_phase.cpp	/^struct structindexlock{$/;"	s	file:
structstoragebuffer	src\filter_phase.cpp	/^struct structstoragebuffer{$/;"	s	file:
wait_threshold	src\filter_phase.cpp	/^    int wait_threshold;$/;"	m	struct:structindexlock	file:
fingerprint_cache_lookup	src\fingerprint_cache.cpp	/^int64_t fingerprint_cache_lookup(fingerprint *fp){$/;"	f
fingerprint_cache_prefetch	src\fingerprint_cache.cpp	/^void fingerprint_cache_prefetch(int64_t id){$/;"	f
init_fingerprint_cache	src\fingerprint_cache.cpp	/^void init_fingerprint_cache(){$/;"	f
lookup_requests	src\fingerprint_cache.cpp	/^	int lookup_requests;$/;"	m	struct:__anon4	file:
lookup_requests_for_unique	src\fingerprint_cache.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon4	file:
lru_queue	src\fingerprint_cache.cpp	/^static struct lruCache* lru_queue;$/;"	v	typeref:struct:lruCache	file:
read_prefetching_units	src\fingerprint_cache.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon4	file:
update_requests	src\fingerprint_cache.cpp	/^	int update_requests;$/;"	m	struct:__anon4	file:
FINGERPRINT_CACHE_H_	src\fingerprint_cache.h	9;"	d
close_har	src\har_rewrite.cpp	/^void close_har() {$/;"	f
container_utilization_monitor	src\har_rewrite.cpp	/^static GHashTable *container_utilization_monitor;$/;"	v	file:
g_record_cmp	src\har_rewrite.cpp	/^static gint g_record_cmp(struct containerRecord *a, struct containerRecord* b, gpointer user_data){$/;"	f	file:
har_check	src\har_rewrite.cpp	/^void har_check(struct chunk* c) {$/;"	f
har_monitor_update	src\har_rewrite.cpp	/^void har_monitor_update(containerid id, int32_t size) {$/;"	f
inherited_sparse_containers	src\har_rewrite.cpp	/^static GHashTable *inherited_sparse_containers;$/;"	v	file:
init_har	src\har_rewrite.cpp	/^void init_har() {$/;"	f
chunk_num	src\hash_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
hash_queue	src\hash_phase.cpp	/^SyncQueue* hash_queue;$/;"	v
hash_t	src\hash_phase.cpp	/^static pthread_t hash_t;$/;"	v	file:
sha1_thread	src\hash_phase.cpp	/^static void* sha1_thread(void* arg) {$/;"	f	file:
start_hash_phase	src\hash_phase.cpp	/^void start_hash_phase() {$/;"	f
stop_hash_phase	src\hash_phase.cpp	/^void stop_hash_phase() {$/;"	f
chunks	src\index.cpp	/^    GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
close_index	src\index.cpp	/^void close_index() {$/;"	f
cond	src\index.cpp	/^    pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
container_buffer	src\index.cpp	/^    struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
g_feature_equal	src\index.cpp	/^gboolean g_feature_equal(char* a, char* b){$/;"	f
g_feature_hash	src\index.cpp	/^guint g_feature_hash(char *feature){$/;"	f
index_buffer	src\index.cpp	/^struct index_buffer index_buffer;$/;"	v	typeref:struct:index_buffer
index_check_buffer	src\index.cpp	/^void index_check_buffer(struct segment *s) {$/;"	f
index_delete	src\index.cpp	/^void index_delete(fingerprint *fp, int64_t id){$/;"	f
index_lookup	src\index.cpp	/^int index_lookup(struct segment* s) {$/;"	f
index_lookup_base	src\index.cpp	/^static void index_lookup_base(struct segment *s){$/;"	f	file:
index_overhead	src\index.cpp	/^struct index_overhead index_overhead;$/;"	v	typeref:struct:index_overhead
index_update	src\index.cpp	/^void index_update(GHashTable *features, int64_t id){$/;"	f
index_update_buffer	src\index.cpp	/^int index_update_buffer(struct segment *s){$/;"	f
init_index	src\index.cpp	/^void init_index() {$/;"	f
mutex	src\index.cpp	/^    pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
structindexlock	src\index.cpp	/^struct structindexlock{$/;"	s	file:
structstoragebuffer	src\index.cpp	/^struct structstoragebuffer{$/;"	s	file:
wait_threshold	src\index.cpp	/^    int wait_threshold;$/;"	m	struct:structindexlock	file:
INDEX_H_	src\index.h	10;"	d
INDEX_BUFFER_H_	src\index_buffer.h	2;"	d
buffered_fingerprints	src\index_buffer.h	/^    GHashTable *buffered_fingerprints;$/;"	m	struct:index_buffer
chunk_num	src\index_buffer.h	/^    int chunk_num;$/;"	m	struct:index_buffer
fp	src\index_buffer.h	/^    fingerprint fp;$/;"	m	struct:indexElem
id	src\index_buffer.h	/^    containerid id;$/;"	m	struct:indexElem
indexElem	src\index_buffer.h	/^struct indexElem {$/;"	s
index_buffer	src\index_buffer.h	/^struct index_buffer {$/;"	s
index_overhead	src\index_buffer.h	/^struct index_overhead {$/;"	s
lookup_requests	src\index_buffer.h	/^    int lookup_requests;$/;"	m	struct:index_overhead
lookup_requests_for_unique	src\index_buffer.h	/^    int lookup_requests_for_unique;$/;"	m	struct:index_overhead
read_prefetching_units	src\index_buffer.h	/^    int read_prefetching_units;$/;"	m	struct:index_overhead
update_requests	src\index_buffer.h	/^    int update_requests;$/;"	m	struct:index_overhead
init_backup_jcr	src\jcr.cpp	/^void init_backup_jcr(char *path) {$/;"	f
init_jcr	src\jcr.cpp	/^void init_jcr(char *path) {$/;"	f
init_restore_jcr	src\jcr.cpp	/^void init_restore_jcr(int revision, char *path) {$/;"	f
jcr	src\jcr.cpp	/^struct structjcr jcr;$/;"	v	typeref:struct:structjcr
JCR_STATUS_DONE	src\jcr.h	17;"	d
JCR_STATUS_INIT	src\jcr.h	15;"	d
JCR_STATUS_RUNNING	src\jcr.h	16;"	d
Jcr_H_	src\jcr.h	9;"	d
bv	src\jcr.h	/^	struct backupVersion* bv;$/;"	m	struct:structjcr	typeref:struct:structjcr::backupVersion
chunk_num	src\jcr.h	/^	int32_t chunk_num;$/;"	m	struct:structjcr
chunk_time	src\jcr.h	/^	double chunk_time;$/;"	m	struct:structjcr
data_size	src\jcr.h	/^	int64_t data_size;$/;"	m	struct:structjcr
dedup_time	src\jcr.h	/^	double dedup_time;$/;"	m	struct:structjcr
file_num	src\jcr.h	/^	int32_t file_num;$/;"	m	struct:structjcr
filter_time	src\jcr.h	/^	double filter_time;$/;"	m	struct:structjcr
hash_time	src\jcr.h	/^	double hash_time;$/;"	m	struct:structjcr
id	src\jcr.h	/^	int32_t id;$/;"	m	struct:structjcr
inherited_sparse_num	src\jcr.h	/^	int32_t inherited_sparse_num;$/;"	m	struct:structjcr
path	src\jcr.h	/^	sds path;$/;"	m	struct:structjcr
read_chunk_time	src\jcr.h	/^	double read_chunk_time;$/;"	m	struct:structjcr
read_container_num	src\jcr.h	/^	int32_t read_container_num;$/;"	m	struct:structjcr
read_recipe_time	src\jcr.h	/^	double read_recipe_time;$/;"	m	struct:structjcr
read_time	src\jcr.h	/^	double read_time;$/;"	m	struct:structjcr
rewrite_time	src\jcr.h	/^	double rewrite_time;$/;"	m	struct:structjcr
rewritten_chunk_num	src\jcr.h	/^	int32_t rewritten_chunk_num;$/;"	m	struct:structjcr
rewritten_chunk_size	src\jcr.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:structjcr
sparse_container_num	src\jcr.h	/^	int32_t sparse_container_num;$/;"	m	struct:structjcr
status	src\jcr.h	/^    int status;$/;"	m	struct:structjcr
structjcr	src\jcr.h	/^struct structjcr{$/;"	s
total_container_num	src\jcr.h	/^	int32_t total_container_num;$/;"	m	struct:structjcr
total_time	src\jcr.h	/^	double total_time;$/;"	m	struct:structjcr
unique_chunk_num	src\jcr.h	/^	int32_t unique_chunk_num;$/;"	m	struct:structjcr
unique_data_size	src\jcr.h	/^	int64_t unique_data_size;$/;"	m	struct:structjcr
write_chunk_time	src\jcr.h	/^	double write_chunk_time;$/;"	m	struct:structjcr
write_time	src\jcr.h	/^	double write_time;$/;"	m	struct:structjcr
zero_chunk_num	src\jcr.h	/^	int32_t zero_chunk_num;$/;"	m	struct:structjcr
zero_chunk_size	src\jcr.h	/^	int64_t zero_chunk_size;$/;"	m	struct:structjcr
close_kvstore	src\kvstore.cpp	/^void (*close_kvstore)();$/;"	v
init_kvstore	src\kvstore.cpp	/^void init_kvstore() {$/;"	f
kvstore_delete	src\kvstore.cpp	/^void (*kvstore_delete)(unsigned char* key, int64_t id);$/;"	v
kvstore_lookup	src\kvstore.cpp	/^int64_t* (*kvstore_lookup)(unsigned char *key);$/;"	v
kvstore_update	src\kvstore.cpp	/^void (*kvstore_update)(unsigned char *key, int64_t id);$/;"	v
KVSTORE_H_	src\kvstore.h	2;"	d
close_kvstore_htable	src\kvstore_htable.cpp	/^void close_kvstore_htable() {$/;"	f
free_kvpair	src\kvstore_htable.cpp	/^static inline void free_kvpair(kvpair kvp){$/;"	f	file:
get_key	src\kvstore_htable.cpp	13;"	d	file:
get_value	src\kvstore_htable.cpp	14;"	d	file:
htable	src\kvstore_htable.cpp	/^static GHashTable *htable;$/;"	v	file:
init_kvstore_htable	src\kvstore_htable.cpp	/^void init_kvstore_htable(){$/;"	f
kv_update	src\kvstore_htable.cpp	/^static void kv_update(kvpair kv, int64_t id){$/;"	f	file:
kvpair	src\kvstore_htable.cpp	/^typedef unsigned char* kvpair;$/;"	t	file:
kvpair_size	src\kvstore_htable.cpp	/^static int32_t kvpair_size;$/;"	v	file:
kvstore_htable_delete	src\kvstore_htable.cpp	/^void kvstore_htable_delete(unsigned char* key, int64_t id){$/;"	f
kvstore_htable_lookup	src\kvstore_htable.cpp	/^int64_t* kvstore_htable_lookup(unsigned char* key) {$/;"	f
kvstore_htable_update	src\kvstore_htable.cpp	/^void kvstore_htable_update(unsigned char* key, int64_t id) {$/;"	f
new_kvpair	src\kvstore_htable.cpp	/^static kvpair new_kvpair(){$/;"	f	file:
new_kvpair_full	src\kvstore_htable.cpp	/^static kvpair new_kvpair_full(unsigned char* key){$/;"	f	file:
FILE_HEADER_SIZE	src\libhashfile.cpp	37;"	d	file:
_FILE_OFFSET_BITS	src\libhashfile.cpp	16;"	d	file:
convert_to_abstract_file_header	src\libhashfile.cpp	/^static void convert_to_abstract_file_header(int version, uint8_t *fhdr,$/;"	f	file:
do_add_file	src\libhashfile.cpp	/^static int do_add_file(struct hashfile_handle *handle, const char *file_path,$/;"	f	file:
hashfile_add_chunk	src\libhashfile.cpp	/^int hashfile_add_chunk(struct hashfile_handle *handle,$/;"	f
hashfile_add_file	src\libhashfile.cpp	/^int hashfile_add_file(struct hashfile_handle *handle,$/;"	f
hashfile_chunking_method	src\libhashfile.cpp	/^enum chnking_method hashfile_chunking_method(struct hashfile_handle *handle)$/;"	f
hashfile_chunking_method_str	src\libhashfile.cpp	/^int hashfile_chunking_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_close	src\libhashfile.cpp	/^void hashfile_close(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_atime	src\libhashfile.cpp	/^uint64_t hashfile_curfile_atime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_blocks	src\libhashfile.cpp	/^uint64_t hashfile_curfile_blocks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_ctime	src\libhashfile.cpp	/^uint64_t hashfile_curfile_ctime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_deviceid	src\libhashfile.cpp	/^uint64_t hashfile_curfile_deviceid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_gid	src\libhashfile.cpp	/^uint32_t hashfile_curfile_gid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_hardlinks	src\libhashfile.cpp	/^uint64_t hashfile_curfile_hardlinks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_inodenum	src\libhashfile.cpp	/^uint64_t hashfile_curfile_inodenum(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_linkpath	src\libhashfile.cpp	/^char *hashfile_curfile_linkpath(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_mtime	src\libhashfile.cpp	/^uint64_t hashfile_curfile_mtime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_numchunks	src\libhashfile.cpp	/^uint64_t hashfile_curfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_path	src\libhashfile.cpp	/^const char *hashfile_curfile_path(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_perm	src\libhashfile.cpp	/^uint64_t hashfile_curfile_perm(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_size	src\libhashfile.cpp	/^uint64_t hashfile_curfile_size(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_uid	src\libhashfile.cpp	/^uint32_t hashfile_curfile_uid(struct hashfile_handle *handle)$/;"	f
hashfile_end_time	src\libhashfile.cpp	/^uint64_t hashfile_end_time(struct hashfile_handle *handle)$/;"	f
hashfile_fxd_chunking_params	src\libhashfile.cpp	/^int hashfile_fxd_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_hash_size	src\libhashfile.cpp	/^uint32_t hashfile_hash_size(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method	src\libhashfile.cpp	/^enum hshing_method hashfile_hashing_method(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method_str	src\libhashfile.cpp	/^int hashfile_hashing_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_next_chunk	src\libhashfile.cpp	/^const struct chunk_info *hashfile_next_chunk(struct hashfile_handle *handle)$/;"	f
hashfile_next_file	src\libhashfile.cpp	/^int hashfile_next_file(struct hashfile_handle *handle)$/;"	f
hashfile_numbytes	src\libhashfile.cpp	/^uint64_t hashfile_numbytes(struct hashfile_handle *handle)$/;"	f
hashfile_numchunks	src\libhashfile.cpp	/^uint64_t hashfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_numfiles	src\libhashfile.cpp	/^uint64_t hashfile_numfiles(struct hashfile_handle *handle)$/;"	f
hashfile_open	src\libhashfile.cpp	/^struct hashfile_handle *hashfile_open(char *hashfile_name)$/;"	f
hashfile_open4write	src\libhashfile.cpp	/^struct hashfile_handle *hashfile_open4write(char *hashfile_name, enum$/;"	f
hashfile_reset	src\libhashfile.cpp	/^int hashfile_reset(struct hashfile_handle *handle)$/;"	f
hashfile_rootpath	src\libhashfile.cpp	/^const char *hashfile_rootpath(struct hashfile_handle *handle)$/;"	f
hashfile_set_fxd_chnking_params	src\libhashfile.cpp	/^int hashfile_set_fxd_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_set_var_chnking_params	src\libhashfile.cpp	/^int hashfile_set_var_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_start_time	src\libhashfile.cpp	/^uint64_t hashfile_start_time(struct hashfile_handle *handle)$/;"	f
hashfile_sysid	src\libhashfile.cpp	/^const char *hashfile_sysid(struct hashfile_handle *handle)$/;"	f
hashfile_var_chunking_params	src\libhashfile.cpp	/^int hashfile_var_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_version	src\libhashfile.cpp	/^uint32_t hashfile_version(struct hashfile_handle *handle)$/;"	f
max	src\libhashfile.cpp	36;"	d	file:
max2	src\libhashfile.cpp	35;"	d	file:
skip_over_current_file_hashes	src\libhashfile.cpp	/^static uint64_t skip_over_current_file_hashes(struct hashfile_handle *handle)$/;"	f	file:
version_supported	src\libhashfile.cpp	/^static inline int version_supported(uint32_t version)$/;"	f	file:
CHUNK_SIZE_32BIT	src\libhashfile.h	371;"	d
CHUNK_SIZE_64BIT	src\libhashfile.h	372;"	d
FIXED	src\libhashfile.h	/^	FIXED = 1,$/;"	e	enum:chnking_method
HASH_FILE_MAGIC	src\libhashfile.h	142;"	d
HASH_FILE_VERSION1	src\libhashfile.h	150;"	d
HASH_FILE_VERSION2	src\libhashfile.h	151;"	d
HASH_FILE_VERSION3	src\libhashfile.h	152;"	d
HASH_FILE_VERSION4	src\libhashfile.h	153;"	d
HASH_FILE_VERSION5	src\libhashfile.h	154;"	d
HASH_FILE_VERSION6	src\libhashfile.h	155;"	d
HASH_FILE_VERSION7	src\libhashfile.h	156;"	d
MAX_PATH_SIZE	src\libhashfile.h	143;"	d
MAX_SYSID_LEN	src\libhashfile.h	144;"	d
MD5_48BIT_HASH	src\libhashfile.h	/^	MD5_48BIT_HASH = 3,$/;"	e	enum:hshing_method
MD5_64BIT_HASH	src\libhashfile.h	/^	MD5_64BIT_HASH = 5,$/;"	e	enum:hshing_method
MD5_HASH	src\libhashfile.h	/^	MD5_HASH = 1,$/;"	e	enum:hshing_method
MURMUR_HASH	src\libhashfile.h	/^	MURMUR_HASH = 4,$/;"	e	enum:hshing_method
NONE	src\libhashfile.h	/^	NONE = 0,$/;"	e	enum:cmpr_method
RABIN	src\libhashfile.h	/^	RABIN = 3$/;"	e	enum:var_chnking_algo
RANDOM	src\libhashfile.h	/^	RANDOM = 1,$/;"	e	enum:var_chnking_algo
READ	src\libhashfile.h	/^	READ = 0,$/;"	e	enum:openmode
SHA1_HASH	src\libhashfile.h	/^	SHA1_HASH = 6,$/;"	e	enum:hshing_method
SHA256_HASH	src\libhashfile.h	/^	SHA256_HASH = 2,$/;"	e	enum:hshing_method
SIMPLE_MATCH	src\libhashfile.h	/^	SIMPLE_MATCH = 2,$/;"	e	enum:var_chnking_algo
VARIABLE	src\libhashfile.h	/^	VARIABLE = 2$/;"	e	enum:chnking_method
WRITE	src\libhashfile.h	/^	WRITE = 1,$/;"	e	enum:openmode
ZLIB_DEF	src\libhashfile.h	/^	ZLIB_DEF = 1$/;"	e	enum:cmpr_method
_HASHFILELIB_H	src\libhashfile.h	17;"	d
abstract_file_header	src\libhashfile.h	/^struct abstract_file_header {$/;"	s
algo	src\libhashfile.h	/^	enum var_chnking_algo algo;$/;"	m	struct:var_chnking_params	typeref:enum:var_chnking_params::var_chnking_algo
algo_params	src\libhashfile.h	/^	} algo_params;$/;"	m	struct:var_chnking_params	typeref:union:var_chnking_params::__anon5
atime	src\libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v3
atime	src\libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v4
atime	src\libhashfile.h	/^	uint64_t atime;$/;"	m	struct:abstract_file_header
bits_to_compare	src\libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_rabin_chnk_params
bits_to_compare	src\libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_simple_chnk_params
blocks	src\libhashfile.h	/^	uint64_t blocks;		\/* 512B blocks allocated by fs *\/$/;"	m	struct:file_header_v4
blocks	src\libhashfile.h	/^	uint64_t blocks;$/;"	m	struct:abstract_file_header
bytes	src\libhashfile.h	/^	uint64_t bytes;$/;"	m	struct:header_v4
chnk_method	src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header	typeref:enum:header::chnking_method
chnk_method	src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::chnking_method
chnk_method	src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::chnking_method
chnk_method_params	src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header	typeref:union:header::__anon6
chnk_method_params	src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v3	typeref:union:header_v3::__anon7
chnk_method_params	src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v4	typeref:union:header_v4::__anon8
chnking_method	src\libhashfile.h	/^enum chnking_method$/;"	g
chunk_info	src\libhashfile.h	/^struct chunk_info {$/;"	s
chunk_size	src\libhashfile.h	/^	uint32_t chunk_size;$/;"	m	struct:fixed_chnking_params
chunks	src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header
chunks	src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v2
chunks	src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v3
chunks	src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v4
chunks	src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header
chunks	src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v3
chunks	src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v4
chunks	src\libhashfile.h	/^	uint64_t chunks;$/;"	m	struct:abstract_file_header
cmpr_method	src\libhashfile.h	/^enum cmpr_method$/;"	g
cratio	src\libhashfile.h	/^	uint8_t cratio;$/;"	m	struct:chunk_info
ctime	src\libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v3
ctime	src\libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v4
ctime	src\libhashfile.h	/^	uint64_t ctime;$/;"	m	struct:abstract_file_header
current_chunk_info	src\libhashfile.h	/^	struct chunk_info		current_chunk_info;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::chunk_info
current_file	src\libhashfile.h	/^	struct abstract_file_header 	current_file;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::abstract_file_header
current_file_header_offset	src\libhashfile.h	/^	off_t				current_file_header_offset;$/;"	m	struct:hashfile_handle
deviceid	src\libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v3
deviceid	src\libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v4
deviceid	src\libhashfile.h	/^	uint64_t deviceid;$/;"	m	struct:abstract_file_header
end_time	src\libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v3
end_time	src\libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v4
fd	src\libhashfile.h	/^	int 				fd;$/;"	m	struct:hashfile_handle
file_header	src\libhashfile.h	/^struct file_header {$/;"	s
file_header_v2	src\libhashfile.h	/^struct file_header_v2 {$/;"	s
file_header_v3	src\libhashfile.h	/^struct file_header_v3 {$/;"	s
file_header_v4	src\libhashfile.h	/^struct file_header_v4 {$/;"	s
file_size	src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header
file_size	src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v2
file_size	src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v3
file_size	src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v4
file_size	src\libhashfile.h	/^	uint64_t file_size;$/;"	m	struct:abstract_file_header
files	src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header
files	src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v3
files	src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v4
fixed_chnking_params	src\libhashfile.h	/^struct fixed_chnking_params$/;"	s
fixed_params	src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header::__anon6	typeref:struct:header::__anon6::fixed_chnking_params
fixed_params	src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v3::__anon7	typeref:struct:header_v3::__anon7::fixed_chnking_params
fixed_params	src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v4::__anon8	typeref:struct:header_v4::__anon8::fixed_chnking_params
gid	src\libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v3
gid	src\libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v4
gid	src\libhashfile.h	/^	uint32_t gid;$/;"	m	struct:abstract_file_header
hardlinks	src\libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v3
hardlinks	src\libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v4
hardlinks	src\libhashfile.h	/^	uint64_t hardlinks;$/;"	m	struct:abstract_file_header
hash	src\libhashfile.h	/^	uint8_t *hash; \/* this points to static memory! *\/$/;"	m	struct:chunk_info
hash_size	src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header
hash_size	src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v3
hash_size	src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v4
hashfile_handle	src\libhashfile.h	/^struct hashfile_handle {$/;"	s
header	src\libhashfile.h	/^	struct header_v4		header;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::header_v4
header	src\libhashfile.h	/^struct header {$/;"	s
header_v3	src\libhashfile.h	/^struct header_v3 {$/;"	s
header_v4	src\libhashfile.h	/^struct header_v4 {$/;"	s
hsh_method	src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header	typeref:enum:header::hshing_method
hsh_method	src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::hshing_method
hsh_method	src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::hshing_method
hshing_method	src\libhashfile.h	/^enum hshing_method$/;"	g
inodenum	src\libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v3
inodenum	src\libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v4
inodenum	src\libhashfile.h	/^	uint64_t inodenum;$/;"	m	struct:abstract_file_header
magic	src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header
magic	src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v3
magic	src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v4
max_csize	src\libhashfile.h	/^	uint32_t max_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
min_csize	src\libhashfile.h	/^	uint32_t min_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
module	src\libhashfile.h	/^	uint64_t module;$/;"	m	struct:var_rabin_chnk_params
mtime	src\libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v3
mtime	src\libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v4
mtime	src\libhashfile.h	/^	uint64_t mtime;$/;"	m	struct:abstract_file_header
num_files_processed	src\libhashfile.h	/^	uint64_t			num_files_processed;$/;"	m	struct:hashfile_handle
num_hashes_processed_current_file	src\libhashfile.h	/^	uint64_t			num_hashes_processed_current_file;$/;"	m	struct:hashfile_handle
omode	src\libhashfile.h	/^	enum openmode			omode;$/;"	m	struct:hashfile_handle	typeref:enum:hashfile_handle::openmode
openmode	src\libhashfile.h	/^enum openmode {$/;"	g
path	src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v2
path	src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v3
path	src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v4
path	src\libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
path	src\libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:file_header
path_root	src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header
path_root	src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v3
path_root	src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v4
pathlen	src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v2
pathlen	src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v3
pathlen	src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v4
pathlen	src\libhashfile.h	/^	uint32_t pathlen;$/;"	m	struct:abstract_file_header
pattern	src\libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_rabin_chnk_params
pattern	src\libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_simple_chnk_params
perm	src\libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v3
perm	src\libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v4
perm	src\libhashfile.h	/^	uint64_t perm;$/;"	m	struct:abstract_file_header
prime	src\libhashfile.h	/^	uint64_t prime;$/;"	m	struct:var_rabin_chnk_params
probability	src\libhashfile.h	/^	long double probability;	\/* probability to chunk a stream *\/$/;"	m	struct:var_random_chnk_params
rabin_params	src\libhashfile.h	/^		struct var_rabin_chnk_params rabin_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_rabin_chnk_params
rnd_params	src\libhashfile.h	/^		struct var_random_chnk_params rnd_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_random_chnk_params
simple_params	src\libhashfile.h	/^		struct var_simple_chnk_params simple_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_simple_chnk_params
size	src\libhashfile.h	/^	uint64_t size;$/;"	m	struct:chunk_info
start_time	src\libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v3
start_time	src\libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v4
sysid	src\libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v3
sysid	src\libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v4
target_path	src\libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v3
target_path	src\libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v4
target_path	src\libhashfile.h	/^	char target_path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
target_pathlen	src\libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v3
target_pathlen	src\libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v4
target_pathlen	src\libhashfile.h	/^	uint32_t target_pathlen;$/;"	m	struct:abstract_file_header
uid	src\libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v3
uid	src\libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v4
uid	src\libhashfile.h	/^	uint32_t uid;$/;"	m	struct:abstract_file_header
var_chnking_algo	src\libhashfile.h	/^enum var_chnking_algo$/;"	g
var_chnking_params	src\libhashfile.h	/^struct var_chnking_params$/;"	s
var_params	src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header::__anon6	typeref:struct:header::__anon6::var_chnking_params
var_params	src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v3::__anon7	typeref:struct:header_v3::__anon7::var_chnking_params
var_params	src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v4::__anon8	typeref:struct:header_v4::__anon8::var_chnking_params
var_rabin_chnk_params	src\libhashfile.h	/^struct var_rabin_chnk_params {$/;"	s
var_random_chnk_params	src\libhashfile.h	/^struct var_random_chnk_params {$/;"	s
var_simple_chnk_params	src\libhashfile.h	/^struct var_simple_chnk_params {$/;"	s
version	src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header
version	src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v3
version	src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v4
window_size	src\libhashfile.h	/^	uint32_t window_size; 		\/* in bytes *\/$/;"	m	struct:var_rabin_chnk_params
free_lru_cache	src\lru_cache.cpp	/^void free_lru_cache(struct lruCache* c) {$/;"	f
lru_cache_hits	src\lru_cache.cpp	/^void* lru_cache_hits(struct lruCache* c, void* user_data,$/;"	f
lru_cache_insert	src\lru_cache.cpp	/^void lru_cache_insert(struct lruCache *c, void* data,$/;"	f
lru_cache_is_full	src\lru_cache.cpp	/^int lru_cache_is_full(struct lruCache* c) {$/;"	f
lru_cache_kicks	src\lru_cache.cpp	/^void lru_cache_kicks(struct lruCache* c, void* user_data,$/;"	f
lru_cache_lookup	src\lru_cache.cpp	/^void* lru_cache_lookup(struct lruCache* c, void* user_data) {$/;"	f
lru_cache_lookup_without_update	src\lru_cache.cpp	/^void* lru_cache_lookup_without_update(struct lruCache* c, void* user_data) {$/;"	f
new_lru_cache	src\lru_cache.cpp	/^struct lruCache* new_lru_cache(int size, void (*free_elem)(void *),$/;"	f
Cache_H_	src\lru_cache.h	9;"	d
INFI_CACHE	src\lru_cache.h	10;"	d
elem_queue	src\lru_cache.h	/^	GList *elem_queue;$/;"	m	struct:lruCache
free_elem	src\lru_cache.h	/^	void (*free_elem)(void *);$/;"	m	struct:lruCache
hit_count	src\lru_cache.h	/^	double hit_count;$/;"	m	struct:lruCache
hit_elem	src\lru_cache.h	/^	int (*hit_elem)(void* elem, void* user_data);$/;"	m	struct:lruCache
lruCache	src\lru_cache.h	/^struct lruCache {$/;"	s
max_size	src\lru_cache.h	/^	int max_size; \/\/ less then zero means infinite cache$/;"	m	struct:lruCache
miss_count	src\lru_cache.h	/^	double miss_count;$/;"	m	struct:lruCache
size	src\lru_cache.h	/^	int size;$/;"	m	struct:lruCache
Node	src\ned_rewrite.cpp	/^}Node[MAX_CONTAINER_COUNT];$/;"	v	typeref:struct:containerchunkcount
all_fp	src\ned_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
chunk_num	src\ned_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunkcount	src\ned_rewrite.cpp	/^	int64_t chunkcount;$/;"	m	struct:containerchunkcount	file:
cond	src\ned_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
containerchunkcount	src\ned_rewrite.cpp	/^	containerchunkcount() {$/;"	f	struct:containerchunkcount
containerchunkcount	src\ned_rewrite.cpp	/^struct containerchunkcount{$/;"	s	file:
id	src\ned_rewrite.cpp	/^	int64_t id;$/;"	m	struct:containerchunkcount	file:
mutex	src\ned_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
ned_rewrite	src\ned_rewrite.cpp	/^void *ned_rewrite(void* arg) {$/;"	f
operator <	src\ned_rewrite.cpp	/^	bool operator < (const containerchunkcount &a) const {$/;"	f	struct:containerchunkcount
real_containerid_to_tmp	src\ned_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
rewrite_buffer_chunk_pt	src\ned_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
structindexlock	src\ned_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
tmp_to_real_containerid	src\ned_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
top	src\ned_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
wait_threshold	src\ned_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
accessRecords	src\optimal_restore.cpp	/^struct accessRecords {$/;"	s	file:
access_record_table	src\optimal_restore.cpp	/^	GHashTable *access_record_table;$/;"	m	struct:__anon9	file:
buffered_access_record_num	src\optimal_restore.cpp	/^	int buffered_access_record_num;$/;"	m	struct:__anon9	file:
cid	src\optimal_restore.cpp	/^	containerid cid;$/;"	m	struct:accessRecords	file:
current_sequence_number	src\optimal_restore.cpp	/^	int current_sequence_number;$/;"	m	struct:__anon9	file:
find_kicked_container	src\optimal_restore.cpp	/^static int find_kicked_container(void *con1, void *ht1) {$/;"	f	file:
find_kicked_container_meta	src\optimal_restore.cpp	/^static int find_kicked_container_meta(void *cm1, void *ht1) {$/;"	f	file:
free_access_records	src\optimal_restore.cpp	/^static void free_access_records(struct accessRecords* r) {$/;"	f	file:
g_access_records_cmp_by_first_seqno	src\optimal_restore.cpp	/^static gint g_access_records_cmp_by_first_seqno(struct accessRecords *a,$/;"	f	file:
init_optimal_cache	src\optimal_restore.cpp	/^void init_optimal_cache() {$/;"	f
lru_queue	src\optimal_restore.cpp	/^	struct lruCache *lru_queue;$/;"	m	struct:__anon9	typeref:struct:__anon9::lruCache	file:
new_access_records	src\optimal_restore.cpp	/^static struct accessRecords* new_access_records(containerid id) {$/;"	f	file:
optimal_cache	src\optimal_restore.cpp	/^} optimal_cache;$/;"	v	typeref:struct:__anon9
optimal_cache_hits	src\optimal_restore.cpp	/^static int optimal_cache_hits(containerid id) {$/;"	f	file:
optimal_cache_insert	src\optimal_restore.cpp	/^static void optimal_cache_insert(containerid id) {$/;"	f	file:
optimal_cache_lookup	src\optimal_restore.cpp	/^static struct chunk* optimal_cache_lookup(fingerprint *fp) {$/;"	f	file:
optimal_cache_window_fill	src\optimal_restore.cpp	/^static void optimal_cache_window_fill() {$/;"	f	file:
optimal_cache_window_slides	src\optimal_restore.cpp	/^static void optimal_cache_window_slides(containerid id) {$/;"	f	file:
optimal_restore_thread	src\optimal_restore.cpp	/^void* optimal_restore_thread(void *arg) {$/;"	f
seqno_queue	src\optimal_restore.cpp	/^	GQueue *seqno_queue;$/;"	m	struct:accessRecords	file:
sorted_records_of_cached_containers	src\optimal_restore.cpp	/^	GSequence *sorted_records_of_cached_containers;$/;"	m	struct:__anon9	file:
victim	src\optimal_restore.cpp	/^struct accessRecords* victim;$/;"	v	typeref:struct:accessRecords
queue_empty	src\queue.cpp	/^void queue_empty(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_find	src\queue.cpp	/^void* queue_find(Queue* queue, int (*hit)(void*, void*), void* data) {$/;"	f
queue_foreach	src\queue.cpp	/^void queue_foreach(Queue *queue, void (*func)(void *data, void *user_data),$/;"	f
queue_free	src\queue.cpp	/^void queue_free(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_get_n	src\queue.cpp	/^void* queue_get_n(Queue *queue, int n) {$/;"	f
queue_init	src\queue.cpp	/^void queue_init(Queue *queue) {$/;"	f
queue_new	src\queue.cpp	/^Queue* queue_new() {$/;"	f
queue_pop	src\queue.cpp	/^void* queue_pop(Queue *queue) {$/;"	f
queue_push	src\queue.cpp	/^void queue_push(Queue *queue, void *element) {$/;"	f
queue_size	src\queue.cpp	/^int queue_size(Queue *queue) {$/;"	f
queue_top	src\queue.cpp	/^void * queue_top(Queue *queue) {$/;"	f
QUEUE_H_	src\queue.h	9;"	d
Queue	src\queue.h	/^} Queue;$/;"	t	typeref:struct:queue_tag
data	src\queue.h	/^	void *data;$/;"	m	struct:queue_ele_tag
elem_num	src\queue.h	/^	int elem_num;$/;"	m	struct:queue_tag
first	src\queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
last	src\queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
next	src\queue.h	/^	struct queue_ele_tag *next;$/;"	m	struct:queue_ele_tag	typeref:struct:queue_ele_tag::queue_ele_tag
queue_ele_t	src\queue.h	/^} queue_ele_t;$/;"	t	typeref:struct:queue_ele_tag
queue_ele_tag	src\queue.h	/^typedef struct queue_ele_tag {$/;"	s
queue_tag	src\queue.h	/^typedef struct queue_tag {$/;"	s
BREAKMARK_VALUE	src\rabin_chunking.cpp	7;"	d	file:
FINGERPRINT_PT	src\rabin_chunking.cpp	6;"	d	file:
MAXBUF	src\rabin_chunking.cpp	4;"	d	file:
MSB64	src\rabin_chunking.cpp	3;"	d	file:
SLIDE	src\rabin_chunking.cpp	9;"	d	file:
T	src\rabin_chunking.cpp	/^UINT64 T[256];$/;"	v
U	src\rabin_chunking.cpp	/^UINT64 U[256];$/;"	v
UINT32	src\rabin_chunking.cpp	/^typedef unsigned int UINT32;$/;"	t	file:
UINT64	src\rabin_chunking.cpp	/^typedef unsigned long long int UINT64;$/;"	t	file:
_cur_pos	src\rabin_chunking.cpp	/^size_t _cur_pos;$/;"	v
_last_pos	src\rabin_chunking.cpp	/^size_t _last_pos;$/;"	v
_num_chunks	src\rabin_chunking.cpp	/^unsigned int _num_chunks;$/;"	v
append8	src\rabin_chunking.cpp	/^UINT64 append8(UINT64 p, unsigned char m) {$/;"	f
buf	src\rabin_chunking.cpp	/^unsigned char buf[size];$/;"	v
bufpos	src\rabin_chunking.cpp	/^int bufpos;$/;"	v
bytemsb	src\rabin_chunking.cpp	/^const char bytemsb[0x100] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5,$/;"	v
calcT	src\rabin_chunking.cpp	/^void calcT(UINT64 poly) {$/;"	f
chunkAlg_init	src\rabin_chunking.cpp	/^void chunkAlg_init() {$/;"	f
eFiles	src\rabin_chunking.cpp	/^char *eFiles[] = { ".pdf", ".rmv", "ra", ".bmp", ".vmem", ".vmdk", ".jpeg",$/;"	v
fls32	src\rabin_chunking.cpp	/^static uint32_t fls32(UINT32 v) {$/;"	f	file:
fls64	src\rabin_chunking.cpp	/^static uint32_t fls64(UINT64 v) {$/;"	f	file:
fp	src\rabin_chunking.cpp	/^UINT64 fp;$/;"	v
normalized_rabin_chunk_data	src\rabin_chunking.cpp	/^int normalized_rabin_chunk_data(unsigned char *p, int n) {$/;"	f
poly	src\rabin_chunking.cpp	/^UINT64 poly;$/;"	v
polymmult	src\rabin_chunking.cpp	/^UINT64 polymmult(UINT64 x, UINT64 y, UINT64 d) {$/;"	f
polymod	src\rabin_chunking.cpp	/^UINT64 polymod(UINT64 nh, UINT64 nl, UINT64 d) {$/;"	f
polymult	src\rabin_chunking.cpp	/^void polymult(UINT64 *php, UINT64 *plp, UINT64 x, UINT64 y) {$/;"	f
rabin_chunk_data	src\rabin_chunking.cpp	/^int rabin_chunk_data(unsigned char *p, int n) {$/;"	f
rabin_mask	src\rabin_chunking.cpp	/^static int rabin_mask = 0;$/;"	v	file:
rabinpoly_init	src\rabin_chunking.cpp	/^void rabinpoly_init(UINT64 p) {$/;"	f
shift	src\rabin_chunking.cpp	/^int shift;$/;"	v
size	src\rabin_chunking.cpp	/^	size = 48$/;"	e	enum:__anon10	file:
slide8	src\rabin_chunking.cpp	/^UINT64 slide8(unsigned char m) {$/;"	f
tttd_chunk_data	src\rabin_chunking.cpp	/^int tttd_chunk_data(unsigned char *p, int n) {$/;"	f
window_init	src\rabin_chunking.cpp	/^void window_init(UINT64 poly) {$/;"	f
windows_reset	src\rabin_chunking.cpp	/^void windows_reset() {$/;"	f
MAXLINE	src\read_fsl_trace.cpp	38;"	d	file:
print_chunk_hash	src\read_fsl_trace.cpp	/^static void print_chunk_hash(uint64_t chunk_count, const uint8_t *hash,$/;"	f	file:
read_fsl_trace	src\read_fsl_trace.cpp	/^void* read_fsl_trace(void *argv)$/;"	f
find_one_file	src\read_phase.cpp	/^static void find_one_file(sds path) {$/;"	f	file:
read_file	src\read_phase.cpp	/^static void read_file(sds path) {$/;"	f	file:
read_queue	src\read_phase.cpp	/^SyncQueue* read_queue;$/;"	v
read_t	src\read_phase.cpp	/^static pthread_t read_t;$/;"	v	file:
read_thread	src\read_phase.cpp	/^static void* read_thread(void *argv) {$/;"	f	file:
start_read_phase	src\read_phase.cpp	/^void start_read_phase() {$/;"	f
stop_read_phase	src\read_phase.cpp	/^void stop_read_phase() {$/;"	f
access_record	src\recipestore.cpp	/^static containerid access_record = TEMPORARY_ID;$/;"	v	file:
append_file_recipe_meta	src\recipestore.cpp	/^void append_file_recipe_meta(struct backupVersion* b, struct fileRecipeMeta* r) {$/;"	f
append_n_chunk_pointers	src\recipestore.cpp	/^void append_n_chunk_pointers(struct backupVersion* b,$/;"	f
append_segment_flag	src\recipestore.cpp	/^segmentid append_segment_flag(struct backupVersion* b, int flag, int segment_size){$/;"	f
backup_version_count	src\recipestore.cpp	/^static int32_t backup_version_count;$/;"	v	file:
backup_version_exists	src\recipestore.cpp	/^int backup_version_exists(int number) {$/;"	f
close_recipe_store	src\recipestore.cpp	/^void close_recipe_store() {$/;"	f
create_backup_version	src\recipestore.cpp	/^struct backupVersion* create_backup_version(const char *path) {$/;"	f
free_backup_version	src\recipestore.cpp	/^void free_backup_version(struct backupVersion *b) {$/;"	f
free_file_recipe_meta	src\recipestore.cpp	/^void free_file_recipe_meta(struct fileRecipeMeta* r) {$/;"	f
free_segment_recipe	src\recipestore.cpp	/^void free_segment_recipe(void *sr1) {$/;"	f
get_next_version_number	src\recipestore.cpp	/^int32_t get_next_version_number() {$/;"	f
id_to_bnum	src\recipestore.cpp	/^static inline int64_t id_to_bnum(segmentid id) {$/;"	f	file:
id_to_off	src\recipestore.cpp	/^static inline int64_t id_to_off(segmentid id) {$/;"	f	file:
id_to_size	src\recipestore.cpp	/^static inline int64_t id_to_size(segmentid id) {$/;"	f	file:
init_recipe_store	src\recipestore.cpp	/^void init_recipe_store() {$/;"	f
lookup_fingerprint_in_segment_recipe	src\recipestore.cpp	/^int lookup_fingerprint_in_segment_recipe(void *sr1, void *fp1) {$/;"	f
make_segment_id	src\recipestore.cpp	/^static inline segmentid make_segment_id(int64_t bid, int64_t off, int64_t size){$/;"	f	file:
metabufsize	src\recipestore.cpp	/^static int metabufsize = 64*1024;$/;"	v	file:
new_file_recipe_meta	src\recipestore.cpp	/^struct fileRecipeMeta* new_file_recipe_meta(char* name) {$/;"	f
new_segment_recipe	src\recipestore.cpp	/^struct segmentRecipe* new_segment_recipe() {$/;"	f
open_backup_version	src\recipestore.cpp	/^struct backupVersion* open_backup_version(int number) {$/;"	f
prefetch_segments	src\recipestore.cpp	/^GQueue* prefetch_segments(segmentid id, int prefetch_num) {$/;"	f
read_next_file_recipe_meta	src\recipestore.cpp	/^struct fileRecipeMeta* read_next_file_recipe_meta(struct backupVersion* b) {$/;"	f
read_next_n_chunk_pointers	src\recipestore.cpp	/^struct chunkPointer* read_next_n_chunk_pointers(struct backupVersion* b, int n,$/;"	f
read_next_n_records	src\recipestore.cpp	/^containerid* read_next_n_records(struct backupVersion* b, int n, int *k) {$/;"	f
read_next_segment	src\recipestore.cpp	/^struct segmentRecipe* read_next_segment(struct backupVersion *bv){$/;"	f
recipepath	src\recipestore.cpp	/^static sds recipepath;$/;"	v	file:
recordbufsize	src\recipestore.cpp	/^static int recordbufsize = 64*1024;$/;"	v	file:
segment_recipe_check_id	src\recipestore.cpp	/^int segment_recipe_check_id(void *sr1, void *id1) {$/;"	f
segment_recipe_foreach	src\recipestore.cpp	/^void segment_recipe_foreach(struct segmentRecipe* sr, void (*func)(fingerprint*, void*), void* data){$/;"	f
update_backup_version	src\recipestore.cpp	/^void update_backup_version(struct backupVersion *b) {$/;"	f
RECIPESTORE_H_	src\recipestore.h	9;"	d
backupVersion	src\recipestore.h	/^struct backupVersion {$/;"	s
bv_num	src\recipestore.h	/^	int32_t bv_num; \/* backup version number start from 0 *\/$/;"	m	struct:backupVersion
chunkPointer	src\recipestore.h	/^struct chunkPointer {$/;"	s
chunknum	src\recipestore.h	/^	int64_t chunknum;$/;"	m	struct:fileRecipeMeta
deleted	src\recipestore.h	/^	int deleted;$/;"	m	struct:backupVersion
fileRecipeMeta	src\recipestore.h	/^struct fileRecipeMeta {$/;"	s
filename	src\recipestore.h	/^	sds filename;$/;"	m	struct:fileRecipeMeta
filesize	src\recipestore.h	/^	int64_t filesize;$/;"	m	struct:fileRecipeMeta
fname_prefix	src\recipestore.h	/^	sds fname_prefix; \/* The prefix of the file names *\/$/;"	m	struct:backupVersion
fp	src\recipestore.h	/^	fingerprint fp;$/;"	m	struct:chunkPointer
id	src\recipestore.h	/^	containerid id;$/;"	m	struct:chunkPointer
id	src\recipestore.h	/^	segmentid id;$/;"	m	struct:segmentRecipe
kvpairs	src\recipestore.h	/^	GHashTable *kvpairs;$/;"	m	struct:segmentRecipe
metabuf	src\recipestore.h	/^	char *metabuf;$/;"	m	struct:backupVersion
metabufoff	src\recipestore.h	/^	int metabufoff;$/;"	m	struct:backupVersion
metadata_fp	src\recipestore.h	/^	FILE *metadata_fp;$/;"	m	struct:backupVersion
number_of_chunks	src\recipestore.h	/^	int64_t number_of_chunks;$/;"	m	struct:backupVersion
number_of_files	src\recipestore.h	/^	int64_t number_of_files;$/;"	m	struct:backupVersion
path	src\recipestore.h	/^	sds path;$/;"	m	struct:backupVersion
recipe_fp	src\recipestore.h	/^	FILE *recipe_fp;$/;"	m	struct:backupVersion
record_fp	src\recipestore.h	/^	FILE *record_fp;$/;"	m	struct:backupVersion
recordbuf	src\recipestore.h	/^	char *recordbuf;$/;"	m	struct:backupVersion
recordbufoff	src\recipestore.h	/^	int recordbufoff;$/;"	m	struct:backupVersion
segmentRecipe	src\recipestore.h	/^struct segmentRecipe {$/;"	s
segmentbuf	src\recipestore.h	/^	char* segmentbuf;$/;"	m	struct:backupVersion
segmentbufoff	src\recipestore.h	/^	int segmentbufoff;$/;"	m	struct:backupVersion
segmentlen	src\recipestore.h	/^	int segmentlen;$/;"	m	struct:backupVersion
size	src\recipestore.h	/^	int32_t size;$/;"	m	struct:chunkPointer
RESTORE_H_	src\restore.h	9;"	d
cache	src\restore_aware.cpp	/^	struct lruCache *cache;$/;"	m	struct:__anon11	typeref:struct:__anon11::lruCache	file:
ccf	src\restore_aware.cpp	/^	int ccf;$/;"	m	struct:__anon11	file:
cfl	src\restore_aware.cpp	/^	double cfl; \/\/ocf\/ccf$/;"	m	struct:__anon11	file:
container_record_check_id	src\restore_aware.cpp	/^static int container_record_check_id(void *a1, void *id1) {$/;"	f	file:
init_restore_aware	src\restore_aware.cpp	/^void init_restore_aware() {$/;"	f
monitor	src\restore_aware.cpp	/^} monitor;$/;"	v	typeref:struct:__anon11
ocf	src\restore_aware.cpp	/^	int ocf; \/\/data amount\/CONTAINER_SIZE$/;"	m	struct:__anon11	file:
restore_aware_contains	src\restore_aware.cpp	/^int restore_aware_contains(containerid id) {$/;"	f
restore_aware_get_cfl	src\restore_aware.cpp	/^double restore_aware_get_cfl() {$/;"	f
restore_aware_update	src\restore_aware.cpp	/^void restore_aware_update(containerid id, int32_t chunklen) {$/;"	f
total_size	src\restore_aware.cpp	/^	int64_t total_size;$/;"	m	struct:__anon11	file:
g_record_cmp_by_id	src\rewrite_phase.cpp	/^gint g_record_cmp_by_id(struct containerRecord* a, struct containerRecord* b,$/;"	f
g_record_descmp_by_length	src\rewrite_phase.cpp	/^gint g_record_descmp_by_length(struct containerRecord* a,$/;"	f
init_rewrite_buffer	src\rewrite_phase.cpp	/^static void init_rewrite_buffer() {$/;"	f	file:
no_rewrite	src\rewrite_phase.cpp	/^static void* no_rewrite(void* arg) {$/;"	f	file:
rewrite_buffer	src\rewrite_phase.cpp	/^struct structrewritebuffer rewrite_buffer;$/;"	v	typeref:struct:structrewritebuffer
rewrite_buffer_pop	src\rewrite_phase.cpp	/^struct chunk* rewrite_buffer_pop() {$/;"	f
rewrite_buffer_push	src\rewrite_phase.cpp	/^int rewrite_buffer_push(struct chunk* c) {$/;"	f
rewrite_buffer_top	src\rewrite_phase.cpp	/^struct chunk* rewrite_buffer_top() {$/;"	f
rewrite_queue	src\rewrite_phase.cpp	/^SyncQueue* rewrite_queue;$/;"	v
rewrite_t	src\rewrite_phase.cpp	/^static pthread_t rewrite_t;$/;"	v	file:
start_rewrite_phase	src\rewrite_phase.cpp	/^void start_rewrite_phase() {$/;"	f
stop_rewrite_phase	src\rewrite_phase.cpp	/^void stop_rewrite_phase() {$/;"	f
MAX_CONTAINER_COUNT	src\rewrite_phase.h	53;"	d
REWRITE_PHASE_H_	src\rewrite_phase.h	9;"	d
chunk_queue	src\rewrite_phase.h	/^	GQueue *chunk_queue;$/;"	m	struct:structrewritebuffer
cid	src\rewrite_phase.h	/^	containerid cid;$/;"	m	struct:containerRecord
containerRecord	src\rewrite_phase.h	/^struct containerRecord {$/;"	s
container_record_seq	src\rewrite_phase.h	/^	GSequence *container_record_seq; \/\/$/;"	m	struct:structrewritebuffer
num	src\rewrite_phase.h	/^	int num;$/;"	m	struct:structrewritebuffer
out_of_order	src\rewrite_phase.h	/^	int32_t out_of_order;$/;"	m	struct:containerRecord
size	src\rewrite_phase.h	/^	int size;$/;"	m	struct:structrewritebuffer
size	src\rewrite_phase.h	/^	int32_t size;$/;"	m	struct:containerRecord
structrewritebuffer	src\rewrite_phase.h	/^struct structrewritebuffer {$/;"	s
index_sampling_min	src\sampling_method.cpp	/^static GHashTable* index_sampling_min(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_optimized_min	src\sampling_method.cpp	/^static GHashTable* index_sampling_optimized_min(GSequence *chunks,$/;"	f	file:
index_sampling_random	src\sampling_method.cpp	/^static GHashTable* index_sampling_random(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_uniform	src\sampling_method.cpp	/^static GHashTable* index_sampling_uniform(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
init_sampling_method	src\sampling_method.cpp	/^void init_sampling_method(){$/;"	f
sampling	src\sampling_method.cpp	/^GHashTable* (*sampling)(GSequence *chunks, int32_t chunk_num);$/;"	v
hex_digit_to_int	src\sds.cpp	/^int hex_digit_to_int(char c) {$/;"	f
is_hex_digit	src\sds.cpp	/^int is_hex_digit(char c) {$/;"	f
main	src\sds.cpp	/^int main(void) {$/;"	f
sdsAllocSize	src\sds.cpp	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsIncrLen	src\sds.cpp	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	src\sds.cpp	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	src\sds.cpp	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdscat	src\sds.cpp	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	src\sds.cpp	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	src\sds.cpp	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	src\sds.cpp	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	src\sds.cpp	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	src\sds.cpp	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	src\sds.cpp	/^void sdsclear(sds s) {$/;"	f
sdscmp	src\sds.cpp	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	src\sds.cpp	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	src\sds.cpp	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	src\sds.cpp	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	src\sds.cpp	/^sds sdsempty(void) {$/;"	f
sdsfree	src\sds.cpp	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	src\sds.cpp	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	src\sds.cpp	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	src\sds.cpp	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdsjoin	src\sds.cpp	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdsmapchars	src\sds.cpp	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	src\sds.cpp	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	src\sds.cpp	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	src\sds.cpp	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	src\sds.cpp	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	src\sds.cpp	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	src\sds.cpp	/^void sdstolower(sds s) {$/;"	f
sdstoupper	src\sds.cpp	/^void sdstoupper(sds s) {$/;"	f
sdstrim	src\sds.cpp	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	src\sds.cpp	/^void sdsupdatelen(sds s) {$/;"	f
SDS_MAX_PREALLOC	src\sds.h	34;"	d
__SDS_H	src\sds.h	32;"	d
buf	src\sds.h	/^    char buf[];$/;"	m	struct:sdshdr
free	src\sds.h	/^    int free;$/;"	m	struct:sdshdr
len	src\sds.h	/^    int len;$/;"	m	struct:sdshdr
sds	src\sds.h	/^typedef char *sds;$/;"	t
sdsavail	src\sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdshdr	src\sds.h	/^struct sdshdr {$/;"	s
sdslen	src\sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
init_segmenting_method	src\segmenting_method.cpp	/^void init_segmenting_method(){$/;"	f
segment_content_defined	src\segmenting_method.cpp	/^static struct segment* segment_content_defined(struct chunk *c) {$/;"	f	file:
segment_file_defined	src\segmenting_method.cpp	/^static struct segment* segment_file_defined(struct chunk *c) {$/;"	f	file:
segment_fixed	src\segmenting_method.cpp	/^static struct segment* segment_fixed(struct chunk * c) {$/;"	f	file:
segmenting	src\segmenting_method.cpp	/^struct segment* (*segmenting)(struct chunk *c);$/;"	v	typeref:struct:segmenting
serial_int16	src\serial.cpp	/^void serial_int16(uint8_t * * const ptr, const int16_t v)$/;"	f
serial_int32	src\serial.cpp	/^void serial_int32(uint8_t * * const ptr, const int32_t v)$/;"	f
serial_int64	src\serial.cpp	/^void serial_int64(uint8_t * * const ptr, const int64_t v)$/;"	f
serial_string	src\serial.cpp	/^void serial_string(uint8_t * * const ptr, const char * const str)$/;"	f
serial_uint16	src\serial.cpp	/^void serial_uint16(uint8_t * * const ptr, const uint16_t v)$/;"	f
serial_uint32	src\serial.cpp	/^void serial_uint32(uint8_t * * const ptr, const uint32_t v)$/;"	f
serial_uint64	src\serial.cpp	/^void serial_uint64(uint8_t * * const ptr, const uint64_t v)$/;"	f
unserial_int16	src\serial.cpp	/^int16_t unserial_int16(uint8_t * * const ptr)$/;"	f
unserial_int32	src\serial.cpp	/^int32_t unserial_int32(uint8_t * * const ptr)$/;"	f
unserial_int64	src\serial.cpp	/^int64_t unserial_int64(uint8_t * * const ptr)$/;"	f
unserial_string	src\serial.cpp	/^void unserial_string(uint8_t * * const ptr, char * const str)$/;"	f
unserial_uint16	src\serial.cpp	/^uint16_t unserial_uint16(uint8_t * * const ptr)$/;"	f
unserial_uint32	src\serial.cpp	/^uint32_t unserial_uint32(uint8_t * * const ptr)$/;"	f
unserial_uint64	src\serial.cpp	/^uint64_t unserial_uint64(uint8_t * * const ptr)$/;"	f
__SERIAL_H_	src\serial.h	35;"	d
ser_begin	src\serial.h	42;"	d
ser_btime	src\serial.h	81;"	d
ser_bytes	src\serial.h	87;"	d
ser_check	src\serial.h	56;"	d
ser_declare	src\serial.h	38;"	d
ser_end	src\serial.h	51;"	d
ser_float64	src\serial.h	84;"	d
ser_int16	src\serial.h	66;"	d
ser_int32	src\serial.h	71;"	d
ser_int64	src\serial.h	76;"	d
ser_int8	src\serial.h	61;"	d
ser_length	src\serial.h	47;"	d
ser_string	src\serial.h	93;"	d
ser_struct	src\serial.h	90;"	d
ser_uint16	src\serial.h	68;"	d
ser_uint32	src\serial.h	73;"	d
ser_uint64	src\serial.h	78;"	d
ser_uint8	src\serial.h	63;"	d
unser_begin	src\serial.h	43;"	d
unser_btime	src\serial.h	118;"	d
unser_bytes	src\serial.h	124;"	d
unser_declare	src\serial.h	39;"	d
unser_end	src\serial.h	52;"	d
unser_float64	src\serial.h	121;"	d
unser_int16	src\serial.h	103;"	d
unser_int32	src\serial.h	108;"	d
unser_int64	src\serial.h	113;"	d
unser_int8	src\serial.h	98;"	d
unser_length	src\serial.h	48;"	d
unser_string	src\serial.h	130;"	d
unser_struct	src\serial.h	127;"	d
unser_uint16	src\serial.h	105;"	d
unser_uint32	src\serial.h	110;"	d
unser_uint64	src\serial.h	115;"	d
unser_uint8	src\serial.h	100;"	d
chunks	src\similarity_detection.cpp	/^	GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
container_buffer	src\similarity_detection.cpp	/^	struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
features_trim	src\similarity_detection.cpp	/^static void features_trim(struct segment *target,$/;"	f	file:
g_segment_cmp_feature_num	src\similarity_detection.cpp	/^static gint g_segment_cmp_feature_num(struct segment* a,$/;"	f	file:
index_lookup_similarity_detection	src\similarity_detection.cpp	/^void index_lookup_similarity_detection(struct segment *s){$/;"	f
structstoragebuffer	src\similarity_detection.cpp	/^struct structstoragebuffer{$/;"	s	file:
top_segment_select	src\similarity_detection.cpp	/^static void top_segment_select(GHashTable* features) {$/;"	f	file:
all_fp	src\smr_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
chunk_num	src\smr_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
cond	src\smr_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
container_selected	src\smr_rewrite.cpp	/^vector <int> container_selected;$/;"	v
is_container_selected	src\smr_rewrite.cpp	/^bool is_container_selected[MAX_CONTAINER_COUNT];$/;"	v
mutex	src\smr_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
real_containerid_to_tmp	src\smr_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
rewrite_buffer_chunk_pt	src\smr_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
smr_rewrite	src\smr_rewrite.cpp	/^void *smr_rewrite(void* arg) {$/;"	f
structindexlock	src\smr_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
tmp_to_real_containerid	src\smr_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
top	src\smr_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
wait_threshold	src\smr_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
sync_queue_find	src\sync_queue.cpp	/^void* sync_queue_find(SyncQueue* s_queue, int (*hit)(void*, void*), void* data,$/;"	f
sync_queue_free	src\sync_queue.cpp	/^void sync_queue_free(SyncQueue* s_queue, void (*free_data)(void*)) {$/;"	f
sync_queue_get_top	src\sync_queue.cpp	/^void* sync_queue_get_top(SyncQueue* s_queue) {$/;"	f
sync_queue_new	src\sync_queue.cpp	/^SyncQueue* sync_queue_new(int size) {$/;"	f
sync_queue_pop	src\sync_queue.cpp	/^void* sync_queue_pop(SyncQueue* s_queue) {$/;"	f
sync_queue_push	src\sync_queue.cpp	/^void sync_queue_push(SyncQueue* s_queue, void* item) {$/;"	f
sync_queue_size	src\sync_queue.cpp	/^int sync_queue_size(SyncQueue* s_queue) {$/;"	f
sync_queue_term	src\sync_queue.cpp	/^void sync_queue_term(SyncQueue* s_queue) {$/;"	f
SYNC_QUEUE_H_	src\sync_queue.h	2;"	d
SyncQueue	src\sync_queue.h	/^} SyncQueue;$/;"	t	typeref:struct:__anon12
max_size	src\sync_queue.h	/^	int max_size;\/* the max size of queue *\/$/;"	m	struct:__anon12
max_work	src\sync_queue.h	/^	pthread_cond_t max_work;$/;"	m	struct:__anon12
min_work	src\sync_queue.h	/^	pthread_cond_t min_work;$/;"	m	struct:__anon12
mutex	src\sync_queue.h	/^	pthread_mutex_t mutex;$/;"	m	struct:__anon12
queue	src\sync_queue.h	/^	Queue *queue;$/;"	m	struct:__anon12
term	src\sync_queue.h	/^	int term; \/\/ terminated$/;"	m	struct:__anon12
make_trace	src\trace_phase.cpp	/^void make_trace(char* path) {$/;"	f
read_trace_thread	src\trace_phase.cpp	/^static void* read_trace_thread(void *argv) {$/;"	f	file:
start_read_trace_phase	src\trace_phase.cpp	/^void start_read_trace_phase() {$/;"	f
stop_read_trace_phase	src\trace_phase.cpp	/^void stop_read_trace_phase() {$/;"	f
trace_queue	src\trace_phase.cpp	/^SyncQueue* trace_queue;$/;"	v
trace_t	src\trace_phase.cpp	/^static pthread_t trace_t;$/;"	v	file:
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
